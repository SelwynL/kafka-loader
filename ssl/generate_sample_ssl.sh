#!/usr/bin/env bash
set -e

# Grab current file location so temporary files are relative to this script
CUR_DIR="$( cd $(dirname $0) ; pwd -P )"
echo
echo "Welcome to the Kafka SSL keystore and trusttore generator script."
echo "All temp files will be generated here: ${CUR_DIR}"

### START VARIABLE SECTION

## Grab variables shared between this script and 'docker-compose.yml'
source ${CUR_DIR}/../.env

### These can be changed to change the files and their contents generated by this script
VALIDITY_IN_DAYS=3650

DELETE_INTERMEDIATE_FILES="y"
CREATE_CREDENTIAL_FILES="y"

KEYSTORE_SIGN_REQUEST="cert-file"
KEYSTORE_SIGN_REQUEST_SRL="ca-cert.srl"
KEYSTORE_SIGNED_CERT="cert-signed"

CA_CERT_FILE="ca-cert"

### END VARIABLE SECTION

function file_exists_and_exit() {
  echo "'$1' cannot exist. Move or delete it before re-running this script."
  exit 1
}

function variable_does_not_exist_and_exit() {
  echo "'$1' is undefined. Define it before re-running this script."
  exit 1
}

if [ "$KEYSTORE_PWD" == "" ]; then
  variable_does_not_exist_and_exit KEYSTORE_PWD
fi

if [ "$TRUSTSTORE_PWD" == "" ]; then
  variable_does_not_exist_and_exit TRUSTSTORE_PWD
fi

if [ "$SSLKEY_PWD" == "" ]; then
  variable_does_not_exist_and_exit SSLKEY_PWD
fi

if [ "$DISTINGUISHED_NAME" == "" ]; then
  variable_does_not_exist_and_exit DISTINGUISHED_NAME
fi

if [ "$SSL_DIR_SSLKEY_CRED_FILENAME" == "" ]; then
  variable_does_not_exist_and_exit SSL_DIR_SSLKEY_CRED_FILENAME
fi

if [ "$SSL_DIR_KEYSTORE_CRED_FILENAME" == "" ]; then
  variable_does_not_exist_and_exit SSL_DIR_KEYSTORE_CRED_FILENAME
fi

if [ "$SSL_DIR_TRUSTSTORE_CRED_FILENAME" == "" ]; then
  variable_does_not_exist_and_exit SSL_DIR_TRUSTSTORE_CRED_FILENAME
fi

if [ "$SSL_DIR_TRUSTSTORE_FILENAME" == "" ]; then
  variable_does_not_exist_and_exit SSL_DIR_TRUSTSTORE_FILENAME
fi

if [ "$SSL_DIR_KEYSTORE_FILENAME" == "" ]; then
  variable_does_not_exist_and_exit SSL_DIR_KEYSTORE_FILENAME
fi

if [ -e "$CA_CERT_FILE" ]; then
  file_exists_and_exit $CA_CERT_FILE
fi

if [ -e "$KEYSTORE_SIGN_REQUEST" ]; then
  file_exists_and_exit $KEYSTORE_SIGN_REQUEST
fi

if [ -e "$KEYSTORE_SIGN_REQUEST_SRL" ]; then
  file_exists_and_exit $KEYSTORE_SIGN_REQUEST_SRL
fi

if [ -e "$KEYSTORE_SIGNED_CERT" ]; then
  file_exists_and_exit $KEYSTORE_SIGNED_CERT
fi

# Determine file locations based on defined variables
KEYSTORE_CREDENTIALS_WORKING_DIRECTORY="${CUR_DIR}/$(dirname $SSL_DIR_KEYSTORE_CRED_FILENAME)"
KEYSTORE_CREDENTIAL_FILENAME="$(basename $SSL_DIR_KEYSTORE_CRED_FILENAME)"
TRUSTSTORE_CREDENTIALS_WORKING_DIRECTORY="${CUR_DIR}/$(dirname $SSL_DIR_TRUSTSTORE_CRED_FILENAME)"
TRUSTSTORE_CREDENTIAL_FILENAME="$(basename $SSL_DIR_TRUSTSTORE_CRED_FILENAME)"
SSLKEY_CREDENTIALS_WORKING_DIRECTORY="${CUR_DIR}/$(dirname $SSL_DIR_SSLKEY_CRED_FILENAME)"
SSLKEY_CREDENTIAL_FILENAME="$(basename $SSL_DIR_SSLKEY_CRED_FILENAME)"
TRUSTSTORE_WORKING_DIRECTORY="${CUR_DIR}/$(dirname $SSL_DIR_TRUSTSTORE_FILENAME)"
TRUSTSTORE_FILENAME="$(basename $SSL_DIR_TRUSTSTORE_FILENAME)"
KEYSTORE_WORKING_DIRECTORY="${CUR_DIR}/$(dirname $SSL_DIR_KEYSTORE_FILENAME)"
KEYSTORE_FILENAME="$(basename $SSL_DIR_KEYSTORE_FILENAME)"

if [ -e "$KEYSTORE_WORKING_DIRECTORY" ]; then
  file_exists_and_exit $KEYSTORE_WORKING_DIRECTORY
fi

if [ -e "$TRUSTSTORE_WORKING_DIRECTORY" ]; then
  file_exists_and_exit $TRUSTSTORE_WORKING_DIRECTORY
fi

# Grab pieces from DN
C_NAME=$(echo $DISTINGUISHED_NAME | awk -F"CN=" '{print $2}' | awk -F"," '{print $1}') #"Unknown"
ORG_UNIT=$(echo $DISTINGUISHED_NAME | awk -F"OU=" '{print $2}' | awk -F"," '{print $1}') #"Unknown"
ORG=$(echo $DISTINGUISHED_NAME | awk -F"O=" '{print $2}' | awk -F"," '{print $1}') #"CapitalOne"
CITY=$(echo $DISTINGUISHED_NAME | awk -F"L=" '{print $2}' | awk -F"," '{print $1}') #"SF"
STATE=$(echo $DISTINGUISHED_NAME | awk -F"ST=" '{print $2}' | awk -F"," '{print $1}') #"California"
COUNTRY_CODE=$(echo $DISTINGUISHED_NAME | awk -F"C=" '{print $2}' | awk -F"," '{print $1}') #"US"

# Generate DNs in required formats
DISTINGUISHED_NAME_OPENSSL="/CN=$C_NAME/OU=$ORG_UNIT/O=$ORG/L=$CITY/ST=$STATE/C=$COUNTRY_CODE"
DISTINGUISHED_NAME_KEYTOOL="CN=$C_NAME, OU=$ORG_UNIT, O=$ORG, L=$CITY, S=$STATE, C=$COUNTRY_CODE"

# TODO: currently generates a trust store and private key each time
# TODO: allow using already generated truststore and private key
mkdir -p $TRUSTSTORE_WORKING_DIRECTORY
echo
echo "Generating a trust store private key with the specified SSLKEY_PWD."
echo "NOTE that the Common Name (CN) in the Distinguished Name (DN) is currently not important."
openssl req -new -x509 -passin pass:$SSLKEY_PWD -passout pass:$SSLKEY_PWD -keyout $TRUSTSTORE_WORKING_DIRECTORY/ca-key -out $TRUSTSTORE_WORKING_DIRECTORY/ca-cert -days $VALIDITY_IN_DAYS -subj "$DISTINGUISHED_NAME_OPENSSL"
trust_store_private_key_file="$TRUSTSTORE_WORKING_DIRECTORY/ca-key"

echo
echo "Two files were created:"
echo " - $TRUSTSTORE_WORKING_DIRECTORY/ca-key -- the private key used later to"
echo "   sign certificates"
echo " - $TRUSTSTORE_WORKING_DIRECTORY/ca-cert -- the certificate that will be"
echo "   stored in the trust store in a moment and serve as the certificate"
echo "   authority (CA). Once this certificate has been stored in the trust"
echo "   store, it will be deleted. It can be retrieved from the trust store via:"
echo "   $ keytool -keystore $TRUSTSTORE_WORKING_DIRECTORY/$TRUSTSTORE_FILENAME -export -alias CARoot -rfc"

echo
echo "Generating a trust store from the certificate with the specified TRUSTSTORE_PWD."
keytool -keystore $TRUSTSTORE_WORKING_DIRECTORY/$TRUSTSTORE_FILENAME -storepass $TRUSTSTORE_PWD -keypass $SSLKEY_PWD -noprompt -alias CARoot -import -file $TRUSTSTORE_WORKING_DIRECTORY/ca-cert
trust_store_file="$TRUSTSTORE_WORKING_DIRECTORY/$TRUSTSTORE_FILENAME"

echo
echo "Trust store files created:"
echo " - Trust store file:        $trust_store_file"
echo " - Trust store private key: $trust_store_private_key_file"

# Don't need the cert because it's in the trust store.
rm $TRUSTSTORE_WORKING_DIRECTORY/$CA_CERT_FILE

# TODO: This script will create only one keystore. Each broker and logical client needs its own keystore
# TODO: Run this script multiple times for multiple keystores
mkdir -p $KEYSTORE_WORKING_DIRECTORY
echo
echo "Generating a keystore with the specified KEYSTORE_PWD. Each broker and logical client needs its own, keystore."
echo "NOTE: Currently in Kafka, the Common Name (CN) does not need to be the FQDN of"
echo "      this host. However, at some point, this may change. As such, make the CN"
echo "      the FQDN. Some operating systems call the CN prompt 'first / last name'"
# To learn more about CNs and FQDNs, read:
# https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/X509ExtendedTrustManager.html
keytool -keystore $KEYSTORE_WORKING_DIRECTORY/$KEYSTORE_FILENAME -storepass $KEYSTORE_PWD -keypass $SSLKEY_PWD -dname "$DISTINGUISHED_NAME_KEYTOOL" -alias localhost -validity $VALIDITY_IN_DAYS -genkey -keyalg RSA

echo
echo "'$KEYSTORE_WORKING_DIRECTORY/$KEYSTORE_FILENAME' now contains a key pair and a"
echo "self-signed certificate. Again, this keystore can only be used for one broker or"
echo "one logical client. Other brokers or clients need to generate their OWN keystores."

echo
echo "Fetching the certificate from the trust store and storing in $CA_CERT_FILE, using TRUSTSTORE_PWD"
keytool -keystore $trust_store_file -export -alias CARoot -rfc -file $CA_CERT_FILE -storepass $TRUSTSTORE_PWD

echo
echo "Certificate signing request will be made to the keystore, using KEYSTORE_PWD"
keytool -keystore $KEYSTORE_WORKING_DIRECTORY/$KEYSTORE_FILENAME -alias localhost -certreq -file $KEYSTORE_SIGN_REQUEST -storepass $KEYSTORE_PWD

echo
echo "Trust store's private key (CA) will sign the keystore's certificate, using SSLKEY_PWD"
openssl x509 -req -CA $CA_CERT_FILE -CAkey $trust_store_private_key_file -in $KEYSTORE_SIGN_REQUEST -out $KEYSTORE_SIGNED_CERT -days $VALIDITY_IN_DAYS -CAcreateserial -passin pass:$SSLKEY_PWD

echo
echo "CA will be imported into the keystore, using KEYSTORE_PWD"
keytool -keystore $KEYSTORE_WORKING_DIRECTORY/$KEYSTORE_FILENAME -alias CARoot -import -file $CA_CERT_FILE -storepass $KEYSTORE_PWD -noprompt
# delete the trust store cert because it's stored in the trust store
rm $CA_CERT_FILE

echo
echo "Keystore's signed certificate will be imported back into the keystore, using KEYSTORE_PWD"
keytool -keystore $KEYSTORE_WORKING_DIRECTORY/$KEYSTORE_FILENAME -alias localhost -import -file $KEYSTORE_SIGNED_CERT -storepass $KEYSTORE_PWD

echo
echo "All done!"
echo
echo "Intermediate files are:"
echo " - '$KEYSTORE_SIGN_REQUEST_SRL': CA serial number"
echo " - '$KEYSTORE_SIGN_REQUEST': the keystore's certificate signing request (that was fulfilled)"
echo " - '$KEYSTORE_SIGNED_CERT': the keystore's certificate, signed by the CA, and stored back into the keystore"
if [ "$DELETE_INTERMEDIATE_FILES" == "y" ]; then
  echo "Deleting intermediate files..."
  rm $KEYSTORE_SIGN_REQUEST_SRL
  rm $KEYSTORE_SIGN_REQUEST
  rm $KEYSTORE_SIGNED_CERT
fi

# Kafka Docker configuration requires passwords to be read in from a file.
if [ "$CREATE_CREDENTIAL_FILES" == "y" ]; then
  echo
  echo "Storing credentials in files:"
  echo " - Keystore: $KEYSTORE_CREDENTIALS_WORKING_DIRECTORY/$KEYSTORE_CREDENTIAL_FILENAME"
  echo " - Truststore: $TRUSTSTORE_CREDENTIALS_WORKING_DIRECTORY/$TRUSTSTORE_CREDENTIAL_FILENAME"
  echo " - SSL Key: $SSLKEY_CREDENTIALS_WORKING_DIRECTORY/$SSLKEY_CREDENTIAL_FILENAME"

  mkdir -p $KEYSTORE_CREDENTIALS_WORKING_DIRECTORY
  echo $KEYSTORE_PWD > "$KEYSTORE_CREDENTIALS_WORKING_DIRECTORY/$KEYSTORE_CREDENTIAL_FILENAME"

  mkdir -p $TRUSTSTORE_CREDENTIALS_WORKING_DIRECTORY
  echo $TRUSTSTORE_PWD > "$TRUSTSTORE_CREDENTIALS_WORKING_DIRECTORY/$TRUSTSTORE_CREDENTIAL_FILENAME"

  mkdir -p $SSLKEY_CREDENTIALS_WORKING_DIRECTORY
  echo $SSLKEY_PWD > "$SSLKEY_CREDENTIALS_WORKING_DIRECTORY/$SSLKEY_CREDENTIAL_FILENAME"
fi